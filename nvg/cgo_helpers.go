// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 05 Jun 2018 15:06:16 WAT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package nvg

/*
#include "nanovg.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *Context) Ref() *C.NVGcontext {
	if x == nil {
		return nil
	}
	return (*C.NVGcontext)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Context) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewContextRef converts the C object reference into a raw struct reference without wrapping.
func NewContextRef(ref unsafe.Pointer) *Context {
	return (*Context)(ref)
}

// NewContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewContext() *Context {
	return (*Context)(allocContextMemory(1))
}

// allocContextMemory allocates memory for type C.NVGcontext in C.
// The caller is responsible for freeing the this memory via C.free.
func allocContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfContextValue = unsafe.Sizeof([1]C.NVGcontext{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Context) PassRef() *C.NVGcontext {
	if x == nil {
		x = (*Context)(allocContextMemory(1))
	}
	return (*C.NVGcontext)(unsafe.Pointer(x))
}

// allocColorMemory allocates memory for type C.NVGcolor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorValue = unsafe.Sizeof([1]C.NVGcolor{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Color) Ref() *C.NVGcolor {
	if x == nil {
		return nil
	}
	return x.refab19561b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Color) Free() {
	if x != nil && x.allocsab19561b != nil {
		x.allocsab19561b.(*cgoAllocMap).Free()
		x.refab19561b = nil
	}
}

// NewColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorRef(ref unsafe.Pointer) *Color {
	if ref == nil {
		return nil
	}
	obj := new(Color)
	obj.refab19561b = (*C.NVGcolor)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Color) PassRef() (*C.NVGcolor, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refab19561b != nil {
		return x.refab19561b, nil
	}
	memab19561b := allocColorMemory(1)
	refab19561b := (*C.NVGcolor)(memab19561b)
	allocsab19561b := new(cgoAllocMap)
	allocsab19561b.Add(memab19561b)

	x.refab19561b = refab19561b
	x.allocsab19561b = allocsab19561b
	return refab19561b, allocsab19561b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Color) PassValue() (C.NVGcolor, *cgoAllocMap) {
	if x.refab19561b != nil {
		return *x.refab19561b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Color) Deref() {
	if x.refab19561b == nil {
		return
	}
}

// allocPaintMemory allocates memory for type C.NVGpaint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPaintMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPaintValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPaintValue = unsafe.Sizeof([1]C.NVGpaint{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Paint) Ref() *C.NVGpaint {
	if x == nil {
		return nil
	}
	return x.ref9a359ae5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Paint) Free() {
	if x != nil && x.allocs9a359ae5 != nil {
		x.allocs9a359ae5.(*cgoAllocMap).Free()
		x.ref9a359ae5 = nil
	}
}

// NewPaintRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPaintRef(ref unsafe.Pointer) *Paint {
	if ref == nil {
		return nil
	}
	obj := new(Paint)
	obj.ref9a359ae5 = (*C.NVGpaint)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Paint) PassRef() (*C.NVGpaint, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9a359ae5 != nil {
		return x.ref9a359ae5, nil
	}
	mem9a359ae5 := allocPaintMemory(1)
	ref9a359ae5 := (*C.NVGpaint)(mem9a359ae5)
	allocs9a359ae5 := new(cgoAllocMap)
	allocs9a359ae5.Add(mem9a359ae5)

	var cxform_allocs *cgoAllocMap
	ref9a359ae5.xform, cxform_allocs = *(*[6]C.float)(unsafe.Pointer(&x.Xform)), cgoAllocsUnknown
	allocs9a359ae5.Borrow(cxform_allocs)

	var cextent_allocs *cgoAllocMap
	ref9a359ae5.extent, cextent_allocs = *(*[2]C.float)(unsafe.Pointer(&x.Extent)), cgoAllocsUnknown
	allocs9a359ae5.Borrow(cextent_allocs)

	var cradius_allocs *cgoAllocMap
	ref9a359ae5.radius, cradius_allocs = (C.float)(x.Radius), cgoAllocsUnknown
	allocs9a359ae5.Borrow(cradius_allocs)

	var cfeather_allocs *cgoAllocMap
	ref9a359ae5.feather, cfeather_allocs = (C.float)(x.Feather), cgoAllocsUnknown
	allocs9a359ae5.Borrow(cfeather_allocs)

	var cinnerColor_allocs *cgoAllocMap
	ref9a359ae5.innerColor, cinnerColor_allocs = x.InnerColor.PassValue()
	allocs9a359ae5.Borrow(cinnerColor_allocs)

	var couterColor_allocs *cgoAllocMap
	ref9a359ae5.outerColor, couterColor_allocs = x.OuterColor.PassValue()
	allocs9a359ae5.Borrow(couterColor_allocs)

	var cimage_allocs *cgoAllocMap
	ref9a359ae5.image, cimage_allocs = (C.int)(x.Image), cgoAllocsUnknown
	allocs9a359ae5.Borrow(cimage_allocs)

	x.ref9a359ae5 = ref9a359ae5
	x.allocs9a359ae5 = allocs9a359ae5
	return ref9a359ae5, allocs9a359ae5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Paint) PassValue() (C.NVGpaint, *cgoAllocMap) {
	if x.ref9a359ae5 != nil {
		return *x.ref9a359ae5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Paint) Deref() {
	if x.ref9a359ae5 == nil {
		return
	}
	x.Xform = *(*[6]float32)(unsafe.Pointer(&x.ref9a359ae5.xform))
	x.Extent = *(*[2]float32)(unsafe.Pointer(&x.ref9a359ae5.extent))
	x.Radius = (float32)(x.ref9a359ae5.radius)
	x.Feather = (float32)(x.ref9a359ae5.feather)
	x.InnerColor = *NewColorRef(unsafe.Pointer(&x.ref9a359ae5.innerColor))
	x.OuterColor = *NewColorRef(unsafe.Pointer(&x.ref9a359ae5.outerColor))
	x.Image = (int32)(x.ref9a359ae5.image)
}

// allocCompositeOperationStateMemory allocates memory for type C.NVGcompositeOperationState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCompositeOperationStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCompositeOperationStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCompositeOperationStateValue = unsafe.Sizeof([1]C.NVGcompositeOperationState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CompositeOperationState) Ref() *C.NVGcompositeOperationState {
	if x == nil {
		return nil
	}
	return x.ref1ac74feb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CompositeOperationState) Free() {
	if x != nil && x.allocs1ac74feb != nil {
		x.allocs1ac74feb.(*cgoAllocMap).Free()
		x.ref1ac74feb = nil
	}
}

// NewCompositeOperationStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCompositeOperationStateRef(ref unsafe.Pointer) *CompositeOperationState {
	if ref == nil {
		return nil
	}
	obj := new(CompositeOperationState)
	obj.ref1ac74feb = (*C.NVGcompositeOperationState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CompositeOperationState) PassRef() (*C.NVGcompositeOperationState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1ac74feb != nil {
		return x.ref1ac74feb, nil
	}
	mem1ac74feb := allocCompositeOperationStateMemory(1)
	ref1ac74feb := (*C.NVGcompositeOperationState)(mem1ac74feb)
	allocs1ac74feb := new(cgoAllocMap)
	allocs1ac74feb.Add(mem1ac74feb)

	var csrcRGB_allocs *cgoAllocMap
	ref1ac74feb.srcRGB, csrcRGB_allocs = (C.int)(x.SrcRGB), cgoAllocsUnknown
	allocs1ac74feb.Borrow(csrcRGB_allocs)

	var cdstRGB_allocs *cgoAllocMap
	ref1ac74feb.dstRGB, cdstRGB_allocs = (C.int)(x.DstRGB), cgoAllocsUnknown
	allocs1ac74feb.Borrow(cdstRGB_allocs)

	var csrcAlpha_allocs *cgoAllocMap
	ref1ac74feb.srcAlpha, csrcAlpha_allocs = (C.int)(x.SrcAlpha), cgoAllocsUnknown
	allocs1ac74feb.Borrow(csrcAlpha_allocs)

	var cdstAlpha_allocs *cgoAllocMap
	ref1ac74feb.dstAlpha, cdstAlpha_allocs = (C.int)(x.DstAlpha), cgoAllocsUnknown
	allocs1ac74feb.Borrow(cdstAlpha_allocs)

	x.ref1ac74feb = ref1ac74feb
	x.allocs1ac74feb = allocs1ac74feb
	return ref1ac74feb, allocs1ac74feb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CompositeOperationState) PassValue() (C.NVGcompositeOperationState, *cgoAllocMap) {
	if x.ref1ac74feb != nil {
		return *x.ref1ac74feb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CompositeOperationState) Deref() {
	if x.ref1ac74feb == nil {
		return
	}
	x.SrcRGB = (int32)(x.ref1ac74feb.srcRGB)
	x.DstRGB = (int32)(x.ref1ac74feb.dstRGB)
	x.SrcAlpha = (int32)(x.ref1ac74feb.srcAlpha)
	x.DstAlpha = (int32)(x.ref1ac74feb.dstAlpha)
}

// allocGlyphPositionMemory allocates memory for type C.NVGglyphPosition in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGlyphPositionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGlyphPositionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGlyphPositionValue = unsafe.Sizeof([1]C.NVGglyphPosition{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GlyphPosition) Ref() *C.NVGglyphPosition {
	if x == nil {
		return nil
	}
	return x.ref7a6d48e2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GlyphPosition) Free() {
	if x != nil && x.allocs7a6d48e2 != nil {
		x.allocs7a6d48e2.(*cgoAllocMap).Free()
		x.ref7a6d48e2 = nil
	}
}

// NewGlyphPositionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGlyphPositionRef(ref unsafe.Pointer) *GlyphPosition {
	if ref == nil {
		return nil
	}
	obj := new(GlyphPosition)
	obj.ref7a6d48e2 = (*C.NVGglyphPosition)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GlyphPosition) PassRef() (*C.NVGglyphPosition, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7a6d48e2 != nil {
		return x.ref7a6d48e2, nil
	}
	mem7a6d48e2 := allocGlyphPositionMemory(1)
	ref7a6d48e2 := (*C.NVGglyphPosition)(mem7a6d48e2)
	allocs7a6d48e2 := new(cgoAllocMap)
	allocs7a6d48e2.Add(mem7a6d48e2)

	var cstr_allocs *cgoAllocMap
	ref7a6d48e2.str, cstr_allocs = unpackPCharString(x.Str)
	allocs7a6d48e2.Borrow(cstr_allocs)

	var cx_allocs *cgoAllocMap
	ref7a6d48e2.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs7a6d48e2.Borrow(cx_allocs)

	var cminx_allocs *cgoAllocMap
	ref7a6d48e2.minx, cminx_allocs = (C.float)(x.Minx), cgoAllocsUnknown
	allocs7a6d48e2.Borrow(cminx_allocs)

	var cmaxx_allocs *cgoAllocMap
	ref7a6d48e2.maxx, cmaxx_allocs = (C.float)(x.Maxx), cgoAllocsUnknown
	allocs7a6d48e2.Borrow(cmaxx_allocs)

	x.ref7a6d48e2 = ref7a6d48e2
	x.allocs7a6d48e2 = allocs7a6d48e2
	return ref7a6d48e2, allocs7a6d48e2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GlyphPosition) PassValue() (C.NVGglyphPosition, *cgoAllocMap) {
	if x.ref7a6d48e2 != nil {
		return *x.ref7a6d48e2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GlyphPosition) Deref() {
	if x.ref7a6d48e2 == nil {
		return
	}
	x.Str = packPCharString(x.ref7a6d48e2.str)
	x.X = (float32)(x.ref7a6d48e2.x)
	x.Minx = (float32)(x.ref7a6d48e2.minx)
	x.Maxx = (float32)(x.ref7a6d48e2.maxx)
}

// allocTextRowMemory allocates memory for type C.NVGtextRow in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextRowMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextRowValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextRowValue = unsafe.Sizeof([1]C.NVGtextRow{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextRow) Ref() *C.NVGtextRow {
	if x == nil {
		return nil
	}
	return x.ref6f343350
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextRow) Free() {
	if x != nil && x.allocs6f343350 != nil {
		x.allocs6f343350.(*cgoAllocMap).Free()
		x.ref6f343350 = nil
	}
}

// NewTextRowRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextRowRef(ref unsafe.Pointer) *TextRow {
	if ref == nil {
		return nil
	}
	obj := new(TextRow)
	obj.ref6f343350 = (*C.NVGtextRow)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextRow) PassRef() (*C.NVGtextRow, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f343350 != nil {
		return x.ref6f343350, nil
	}
	mem6f343350 := allocTextRowMemory(1)
	ref6f343350 := (*C.NVGtextRow)(mem6f343350)
	allocs6f343350 := new(cgoAllocMap)
	allocs6f343350.Add(mem6f343350)

	var cstart_allocs *cgoAllocMap
	ref6f343350.start, cstart_allocs = unpackPCharString(x.Start)
	allocs6f343350.Borrow(cstart_allocs)

	var cend_allocs *cgoAllocMap
	ref6f343350.end, cend_allocs = unpackPCharString(x.End)
	allocs6f343350.Borrow(cend_allocs)

	var cnext_allocs *cgoAllocMap
	ref6f343350.next, cnext_allocs = unpackPCharString(x.Next)
	allocs6f343350.Borrow(cnext_allocs)

	var cwidth_allocs *cgoAllocMap
	ref6f343350.width, cwidth_allocs = (C.float)(x.Width), cgoAllocsUnknown
	allocs6f343350.Borrow(cwidth_allocs)

	var cminx_allocs *cgoAllocMap
	ref6f343350.minx, cminx_allocs = (C.float)(x.Minx), cgoAllocsUnknown
	allocs6f343350.Borrow(cminx_allocs)

	var cmaxx_allocs *cgoAllocMap
	ref6f343350.maxx, cmaxx_allocs = (C.float)(x.Maxx), cgoAllocsUnknown
	allocs6f343350.Borrow(cmaxx_allocs)

	x.ref6f343350 = ref6f343350
	x.allocs6f343350 = allocs6f343350
	return ref6f343350, allocs6f343350

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextRow) PassValue() (C.NVGtextRow, *cgoAllocMap) {
	if x.ref6f343350 != nil {
		return *x.ref6f343350, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextRow) Deref() {
	if x.ref6f343350 == nil {
		return
	}
	x.Start = packPCharString(x.ref6f343350.start)
	x.End = packPCharString(x.ref6f343350.end)
	x.Next = packPCharString(x.ref6f343350.next)
	x.Width = (float32)(x.ref6f343350.width)
	x.Minx = (float32)(x.ref6f343350.minx)
	x.Maxx = (float32)(x.ref6f343350.maxx)
}

// allocScissorMemory allocates memory for type C.NVGscissor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocScissorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfScissorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfScissorValue = unsafe.Sizeof([1]C.NVGscissor{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Scissor) Ref() *C.NVGscissor {
	if x == nil {
		return nil
	}
	return x.reff578b010
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Scissor) Free() {
	if x != nil && x.allocsf578b010 != nil {
		x.allocsf578b010.(*cgoAllocMap).Free()
		x.reff578b010 = nil
	}
}

// NewScissorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewScissorRef(ref unsafe.Pointer) *Scissor {
	if ref == nil {
		return nil
	}
	obj := new(Scissor)
	obj.reff578b010 = (*C.NVGscissor)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Scissor) PassRef() (*C.NVGscissor, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff578b010 != nil {
		return x.reff578b010, nil
	}
	memf578b010 := allocScissorMemory(1)
	reff578b010 := (*C.NVGscissor)(memf578b010)
	allocsf578b010 := new(cgoAllocMap)
	allocsf578b010.Add(memf578b010)

	var cxform_allocs *cgoAllocMap
	reff578b010.xform, cxform_allocs = *(*[6]C.float)(unsafe.Pointer(&x.Xform)), cgoAllocsUnknown
	allocsf578b010.Borrow(cxform_allocs)

	var cextent_allocs *cgoAllocMap
	reff578b010.extent, cextent_allocs = *(*[2]C.float)(unsafe.Pointer(&x.Extent)), cgoAllocsUnknown
	allocsf578b010.Borrow(cextent_allocs)

	x.reff578b010 = reff578b010
	x.allocsf578b010 = allocsf578b010
	return reff578b010, allocsf578b010

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Scissor) PassValue() (C.NVGscissor, *cgoAllocMap) {
	if x.reff578b010 != nil {
		return *x.reff578b010, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Scissor) Deref() {
	if x.reff578b010 == nil {
		return
	}
	x.Xform = *(*[6]float32)(unsafe.Pointer(&x.reff578b010.xform))
	x.Extent = *(*[2]float32)(unsafe.Pointer(&x.reff578b010.extent))
}

// allocVertexMemory allocates memory for type C.NVGvertex in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexValue = unsafe.Sizeof([1]C.NVGvertex{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vertex) Ref() *C.NVGvertex {
	if x == nil {
		return nil
	}
	return x.refba8fa51b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vertex) Free() {
	if x != nil && x.allocsba8fa51b != nil {
		x.allocsba8fa51b.(*cgoAllocMap).Free()
		x.refba8fa51b = nil
	}
}

// NewVertexRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexRef(ref unsafe.Pointer) *Vertex {
	if ref == nil {
		return nil
	}
	obj := new(Vertex)
	obj.refba8fa51b = (*C.NVGvertex)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vertex) PassRef() (*C.NVGvertex, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refba8fa51b != nil {
		return x.refba8fa51b, nil
	}
	memba8fa51b := allocVertexMemory(1)
	refba8fa51b := (*C.NVGvertex)(memba8fa51b)
	allocsba8fa51b := new(cgoAllocMap)
	allocsba8fa51b.Add(memba8fa51b)

	var cx_allocs *cgoAllocMap
	refba8fa51b.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocsba8fa51b.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refba8fa51b.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocsba8fa51b.Borrow(cy_allocs)

	var cu_allocs *cgoAllocMap
	refba8fa51b.u, cu_allocs = (C.float)(x.U), cgoAllocsUnknown
	allocsba8fa51b.Borrow(cu_allocs)

	var cv_allocs *cgoAllocMap
	refba8fa51b.v, cv_allocs = (C.float)(x.V), cgoAllocsUnknown
	allocsba8fa51b.Borrow(cv_allocs)

	x.refba8fa51b = refba8fa51b
	x.allocsba8fa51b = allocsba8fa51b
	return refba8fa51b, allocsba8fa51b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vertex) PassValue() (C.NVGvertex, *cgoAllocMap) {
	if x.refba8fa51b != nil {
		return *x.refba8fa51b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Vertex) Deref() {
	if x.refba8fa51b == nil {
		return
	}
	x.X = (float32)(x.refba8fa51b.x)
	x.Y = (float32)(x.refba8fa51b.y)
	x.U = (float32)(x.refba8fa51b.u)
	x.V = (float32)(x.refba8fa51b.v)
}

// allocPathMemory allocates memory for type C.NVGpath in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPathMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPathValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPathValue = unsafe.Sizeof([1]C.NVGpath{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSVertex transforms a sliced Go data structure into plain C format.
func unpackSVertex(x []Vertex) (unpacked *C.NVGvertex, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.NVGvertex) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVertexMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.NVGvertex)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.NVGvertex)(h.Data)
	return
}

// packSVertex reads sliced Go data structure out from plain C format.
func packSVertex(v []Vertex, ptr0 *C.NVGvertex) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexValue]C.NVGvertex)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Path) Ref() *C.NVGpath {
	if x == nil {
		return nil
	}
	return x.ref934ceafa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Path) Free() {
	if x != nil && x.allocs934ceafa != nil {
		x.allocs934ceafa.(*cgoAllocMap).Free()
		x.ref934ceafa = nil
	}
}

// NewPathRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPathRef(ref unsafe.Pointer) *Path {
	if ref == nil {
		return nil
	}
	obj := new(Path)
	obj.ref934ceafa = (*C.NVGpath)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Path) PassRef() (*C.NVGpath, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref934ceafa != nil {
		return x.ref934ceafa, nil
	}
	mem934ceafa := allocPathMemory(1)
	ref934ceafa := (*C.NVGpath)(mem934ceafa)
	allocs934ceafa := new(cgoAllocMap)
	allocs934ceafa.Add(mem934ceafa)

	var cfirst_allocs *cgoAllocMap
	ref934ceafa.first, cfirst_allocs = (C.int)(x.First), cgoAllocsUnknown
	allocs934ceafa.Borrow(cfirst_allocs)

	var ccount_allocs *cgoAllocMap
	ref934ceafa.count, ccount_allocs = (C.int)(x.Count), cgoAllocsUnknown
	allocs934ceafa.Borrow(ccount_allocs)

	var cclosed_allocs *cgoAllocMap
	ref934ceafa.closed, cclosed_allocs = (C.uchar)(x.Closed), cgoAllocsUnknown
	allocs934ceafa.Borrow(cclosed_allocs)

	var cnbevel_allocs *cgoAllocMap
	ref934ceafa.nbevel, cnbevel_allocs = (C.int)(x.Nbevel), cgoAllocsUnknown
	allocs934ceafa.Borrow(cnbevel_allocs)

	var cfill_allocs *cgoAllocMap
	ref934ceafa.fill, cfill_allocs = unpackSVertex(x.Fill)
	allocs934ceafa.Borrow(cfill_allocs)

	var cnfill_allocs *cgoAllocMap
	ref934ceafa.nfill, cnfill_allocs = (C.int)(x.Nfill), cgoAllocsUnknown
	allocs934ceafa.Borrow(cnfill_allocs)

	var cstroke_allocs *cgoAllocMap
	ref934ceafa.stroke, cstroke_allocs = unpackSVertex(x.Stroke)
	allocs934ceafa.Borrow(cstroke_allocs)

	var cnstroke_allocs *cgoAllocMap
	ref934ceafa.nstroke, cnstroke_allocs = (C.int)(x.Nstroke), cgoAllocsUnknown
	allocs934ceafa.Borrow(cnstroke_allocs)

	var cwinding_allocs *cgoAllocMap
	ref934ceafa.winding, cwinding_allocs = (C.int)(x.Winding), cgoAllocsUnknown
	allocs934ceafa.Borrow(cwinding_allocs)

	var cconvex_allocs *cgoAllocMap
	ref934ceafa.convex, cconvex_allocs = (C.int)(x.Convex), cgoAllocsUnknown
	allocs934ceafa.Borrow(cconvex_allocs)

	x.ref934ceafa = ref934ceafa
	x.allocs934ceafa = allocs934ceafa
	return ref934ceafa, allocs934ceafa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Path) PassValue() (C.NVGpath, *cgoAllocMap) {
	if x.ref934ceafa != nil {
		return *x.ref934ceafa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Path) Deref() {
	if x.ref934ceafa == nil {
		return
	}
	x.First = (int32)(x.ref934ceafa.first)
	x.Count = (int32)(x.ref934ceafa.count)
	x.Closed = (byte)(x.ref934ceafa.closed)
	x.Nbevel = (int32)(x.ref934ceafa.nbevel)
	packSVertex(x.Fill, x.ref934ceafa.fill)
	x.Nfill = (int32)(x.ref934ceafa.nfill)
	packSVertex(x.Stroke, x.ref934ceafa.stroke)
	x.Nstroke = (int32)(x.ref934ceafa.nstroke)
	x.Winding = (int32)(x.ref934ceafa.winding)
	x.Convex = (int32)(x.ref934ceafa.convex)
}

// allocParamsMemory allocates memory for type C.NVGparams in C.
// The caller is responsible for freeing the this memory via C.free.
func allocParamsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfParamsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfParamsValue = unsafe.Sizeof([1]C.NVGparams{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Params) Ref() *C.NVGparams {
	if x == nil {
		return nil
	}
	return x.refdcb0d2dd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Params) Free() {
	if x != nil && x.allocsdcb0d2dd != nil {
		x.allocsdcb0d2dd.(*cgoAllocMap).Free()
		x.refdcb0d2dd = nil
	}
}

// NewParamsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewParamsRef(ref unsafe.Pointer) *Params {
	if ref == nil {
		return nil
	}
	obj := new(Params)
	obj.refdcb0d2dd = (*C.NVGparams)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Params) PassRef() (*C.NVGparams, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdcb0d2dd != nil {
		return x.refdcb0d2dd, nil
	}
	memdcb0d2dd := allocParamsMemory(1)
	refdcb0d2dd := (*C.NVGparams)(memdcb0d2dd)
	allocsdcb0d2dd := new(cgoAllocMap)
	allocsdcb0d2dd.Add(memdcb0d2dd)

	var cuserPtr_allocs *cgoAllocMap
	refdcb0d2dd.userPtr, cuserPtr_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.UserPtr)), cgoAllocsUnknown
	allocsdcb0d2dd.Borrow(cuserPtr_allocs)

	var cedgeAntiAlias_allocs *cgoAllocMap
	refdcb0d2dd.edgeAntiAlias, cedgeAntiAlias_allocs = (C.int)(x.EdgeAntiAlias), cgoAllocsUnknown
	allocsdcb0d2dd.Borrow(cedgeAntiAlias_allocs)

	var crenderCreate_allocs *cgoAllocMap
	refdcb0d2dd.renderCreate, crenderCreate_allocs = x.RenderCreate.PassRef()
	allocsdcb0d2dd.Borrow(crenderCreate_allocs)

	var crenderCreateTexture_allocs *cgoAllocMap
	refdcb0d2dd.renderCreateTexture, crenderCreateTexture_allocs = x.RenderCreateTexture.PassRef()
	allocsdcb0d2dd.Borrow(crenderCreateTexture_allocs)

	var crenderDeleteTexture_allocs *cgoAllocMap
	refdcb0d2dd.renderDeleteTexture, crenderDeleteTexture_allocs = x.RenderDeleteTexture.PassRef()
	allocsdcb0d2dd.Borrow(crenderDeleteTexture_allocs)

	var crenderUpdateTexture_allocs *cgoAllocMap
	refdcb0d2dd.renderUpdateTexture, crenderUpdateTexture_allocs = x.RenderUpdateTexture.PassRef()
	allocsdcb0d2dd.Borrow(crenderUpdateTexture_allocs)

	var crenderGetTextureSize_allocs *cgoAllocMap
	refdcb0d2dd.renderGetTextureSize, crenderGetTextureSize_allocs = x.RenderGetTextureSize.PassRef()
	allocsdcb0d2dd.Borrow(crenderGetTextureSize_allocs)

	var crenderViewport_allocs *cgoAllocMap
	refdcb0d2dd.renderViewport, crenderViewport_allocs = x.RenderViewport.PassRef()
	allocsdcb0d2dd.Borrow(crenderViewport_allocs)

	var crenderCancel_allocs *cgoAllocMap
	refdcb0d2dd.renderCancel, crenderCancel_allocs = x.RenderCancel.PassRef()
	allocsdcb0d2dd.Borrow(crenderCancel_allocs)

	var crenderFlush_allocs *cgoAllocMap
	refdcb0d2dd.renderFlush, crenderFlush_allocs = x.RenderFlush.PassRef()
	allocsdcb0d2dd.Borrow(crenderFlush_allocs)

	var crenderFill_allocs *cgoAllocMap
	refdcb0d2dd.renderFill, crenderFill_allocs = x.RenderFill.PassRef()
	allocsdcb0d2dd.Borrow(crenderFill_allocs)

	var crenderStroke_allocs *cgoAllocMap
	refdcb0d2dd.renderStroke, crenderStroke_allocs = x.RenderStroke.PassRef()
	allocsdcb0d2dd.Borrow(crenderStroke_allocs)

	var crenderTriangles_allocs *cgoAllocMap
	refdcb0d2dd.renderTriangles, crenderTriangles_allocs = x.RenderTriangles.PassRef()
	allocsdcb0d2dd.Borrow(crenderTriangles_allocs)

	var crenderDelete_allocs *cgoAllocMap
	refdcb0d2dd.renderDelete, crenderDelete_allocs = x.RenderDelete.PassRef()
	allocsdcb0d2dd.Borrow(crenderDelete_allocs)

	x.refdcb0d2dd = refdcb0d2dd
	x.allocsdcb0d2dd = allocsdcb0d2dd
	return refdcb0d2dd, allocsdcb0d2dd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Params) PassValue() (C.NVGparams, *cgoAllocMap) {
	if x.refdcb0d2dd != nil {
		return *x.refdcb0d2dd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Params) Deref() {
	if x.refdcb0d2dd == nil {
		return
	}
	x.UserPtr = (unsafe.Pointer)(unsafe.Pointer(x.refdcb0d2dd.userPtr))
	x.EdgeAntiAlias = (int32)(x.refdcb0d2dd.edgeAntiAlias)
	x.RenderCreate = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderCreate))
	x.RenderCreateTexture = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderCreateTexture))
	x.RenderDeleteTexture = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderDeleteTexture))
	x.RenderUpdateTexture = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderUpdateTexture))
	x.RenderGetTextureSize = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderGetTextureSize))
	x.RenderViewport = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderViewport))
	x.RenderCancel = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderCancel))
	x.RenderFlush = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderFlush))
	x.RenderFill = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderFill))
	x.RenderStroke = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderStroke))
	x.RenderTriangles = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderTriangles))
	x.RenderDelete = NewRef(unsafe.Pointer(x.refdcb0d2dd.renderDelete))
}

// unpackPUcharString represents the data from Go string as *C.uchar and avoids copying.
func unpackPUcharString(str string) (*C.uchar, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.uchar)(h.Data), cgoAllocsUnknown
}
